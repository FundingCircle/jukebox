#!/usr/bin/env ruby
# frozen_string_literal: true

require 'faye/websocket'
require 'eventmachine'
require 'json'
require 'optparse'
require 'securerandom'

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: jlc_ruby [options]'

  opts.on('-p PORT', '--port PORT', Integer, 'Connect to step coordinator at PORT') do |port|
    options[:port] = port
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

end.parse!

raise OptionParser::MissingArgument if options[:port].nil?

def logf(message)
  p "JLC (ruby): #{message}"
end

logf "Connecting to port #{options[:port]}"
logf "Loading ruby step definitions"
Dir["./features/step_definitions/*.rb"].each { |file| require file }

EM.run {
  ws = Faye::WebSocket::Client.new("ws://localhost:#{options[:port]}/jukebox")

  ws.on :open do |event|
    p [:open]
    clientid = SecureRandom.uuid
    logf 'Connection established'
    logf "Registering as clientid #{clientid}"
    logf "Registering step inventory: #{Jukebox.steps.keys}"
    ws.send(JSON[{
      'action': 'register',
      'clientid': clientid,
      'language': 'ruby',
      'version': '1',
      'steps': Jukebox.steps.keys
    }])
    registered = true
  end

  ws.on :message do |event|
    # p [:message, event.data]
    message = JSON.parse(event.data)
    case message['action']
    when 'step'
      logf "Running step: #{message['step']}"
      message['action'] = 'result'
      message['board'] = Jukebox.run_step(message['step'], message['board'], message['args'])
      ws.send(JSON[message])
    when 'stop'
      log 'Closing connection'
      ws.close
    else
      logf "Don't know how to handle request: #{message}"
    end
  end

  ws.on :error do |event|
    logf "Error: #{event}"
  end

  ws.on :close do |event|
    p [:close, event.code, event.reason]
    ws = nil
    logf 'Closed connection'
  end
}
