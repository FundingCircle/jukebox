#!/usr/bin/env ruby
# frozen_string_literal: true

require 'eventmachine'
require 'faye/websocket'
require 'logger'
require 'json'
require 'jukebox'
require 'optparse'
require 'securerandom'

@logger = Logger.new(STDOUT)
@logger.level = Logger::ERROR

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: jlc_ruby [options]'

  opts.on('-p PORT', '--port PORT', Integer, 'Connect to step coordinator at PORT') do |port|
    options[:port] = port
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

end.parse!

raise OptionParser::MissingArgument if options[:port].nil?

@logger.debug("Connecting to port #{options[:port]}")
@logger.debug("Loading ruby step definitions")
Dir["./features/step_definitions/*.rb"].each { |file| require file }

EM.run {
  ws = Faye::WebSocket::Client.new("ws://localhost:#{options[:port]}/jukebox")

  ws.on :open do |event|
    @logger.debug([:open])
    clientid = SecureRandom.uuid
    @logger.debug('Connection established')
    @logger.debug("Registering as clientid #{clientid}")
    @logger.debug("Registering step inventory: #{Jukebox.steps.keys}")
    ws.send(JSON[{
      'action': 'register',
      'clientid': clientid,
      'language': 'ruby',
      'version': '1',
      'steps': Jukebox.steps.keys
    }])
    registered = true
  end

  ws.on :message do |event|
    message = JSON.parse(event.data)
    case message['action']
    when 'step'
      @logger.debug("Running step: #{message['step']}")
      message['action'] = 'result'
      message['board'] = Jukebox.run_step(message['step'], message['board'], message['args'])
      ws.send(JSON[message])
    when 'stop'
      @logger.debug('Closing connection')
      ws.close
    else
      @logger.error("Don't know how to handle request: #{message}")
    end
  end

  ws.on :error do |event|
    @logger.error("Error: #{event}")
  end

  ws.on :close do |event|
    @logger.debug([:close, event.code, event.reason])
    ws = nil
    @logger.debug('Closed connection')
  end
}
