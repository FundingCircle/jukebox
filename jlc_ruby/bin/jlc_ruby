#!/usr/bin/env ruby
# frozen_string_literal: true

require 'eventmachine'
require 'faye/websocket'
require 'logger'
require 'jukebox'
require 'json'
require 'optparse'
require 'securerandom'

@logger = Logger.new(STDOUT)
@logger.level = Logger::DEBUG

@logger.debug("GEM_PATH: #{ENV['GEM_PATH']}")
p "Log level: #{@logger.level}"

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: jlc_ruby [options] <glue paths>'

  opts.on('-p PORT', '--port PORT', Integer, 'Connect to step coordinator at PORT') do |port|
    options[:port] = port
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

end.parse!
glue_paths = ARGV

raise OptionParser::MissingArgument, 'No glue_paths specified' if glue_paths.empty?
raise OptionParser::MissingArgument 'No port specified' if options[:port].nil?

$:.unshift "lib"

p("Loading ruby step definitions in glue paths: #{glue_paths}")
glue_paths.each do |path|
  @logger.debug("Scanning glue path: #{path}")
  $:.unshift "./#{path}/support"
  Dir["./#{path}/**/support/**/*.rb"].sort.each { |file|
    p "Loading GLUE file: #{file}"
    # Jukebox::load_glue(file)
    require file
  }
  Dir["./#{path}/**/step_definitions/**/*.rb"].sort.each { |file|
    p "Loading GLUE file: #{file}"
    Jukebox::load_glue(file)
  }
end

@logger.debug("Connecting to port #{options[:port]}")

EM.run {
  ws = Faye::WebSocket::Client.new("ws://localhost:#{options[:port]}/jukebox")

  ws.on :open do |event|
    @logger.debug([:open])
    clientid = SecureRandom.uuid
    @logger.debug('Connection established')
    @logger.debug("Registering as clientid #{clientid}")
    @logger.debug("Registering step inventory: #{Jukebox.steps.keys}")
    ws.send(JSON[{
      'action': 'register',
      'clientid': clientid,
      'language': 'ruby',
      'version': '1',
      'steps': Jukebox.steps.keys
    }])
    registered = true
  end

  ws.on :message do |event|
    message = JSON.parse(event.data)
    case message['action']
    when 'step'
      @logger.debug("Running step: #{message['step']}")
      message['action'] = 'result'
      message['board'] = Jukebox.run_step(message['step'], message['board'], message['args'])
      ws.send(JSON[message])
    when 'stop'
      @logger.debug('Closing connection')
      ws.close
    else
      @logger.error("Don't know how to handle request: #{message}")
    end
  end

  ws.on :error do |event|
    @logger.error("Error: #{event}")
  end

  ws.on :close do |event|
    @logger.debug([:close, event.code, event.reason])
    ws = nil
    @logger.debug('Closed connection')
  end
}
